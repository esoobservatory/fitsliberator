<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb Namespace Reference</h1>The namespace tbb contains all components of the library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">tbb::aligned_space&lt; T, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00164.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">tbb::atomic&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary template for atomic.  <a href="a00165.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::atomic&lt; T * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::atomic&lt; void * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::atomic&lt; bool &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">tbb::blocked_range&lt; Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00169.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">tbb::blocked_range2d&lt; RowValue, ColValue &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00170.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">tbb::blocked_range3d&lt; PageValue, RowValue, ColValue &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00171.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">tbb::cache_aligned_allocator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5  <a href="a00172.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::cache_aligned_allocator&lt; T &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html">tbb::cache_aligned_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00173.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::cache_aligned_allocator&lt; void &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unordered map from Key to T.  <a href="a00174.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00176.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00175.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::node</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic unit of storage used in chain. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::chain</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linked-list of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::segment</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segment of the table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">tbb::concurrent_queue&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe queue.  <a href="a00177.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_queue&lt; T, A &gt;::destroyer</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to ensure exception-safety of method "pop". <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">tbb::concurrent_vector&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concurrent vector container  <a href="a00182.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_vector&lt; T, A &gt;::generic_range_type&lt; I &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception-aware helper class for filling a segment by exception-danger operators of user class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">tbb::mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00198.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">tbb::mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00199.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">tbb::parallel_do_feeder&lt; Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class the user supplied algorithm body uses to add new tasks  <a href="a00201.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">tbb::pre_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00207.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">tbb::final_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00190.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">tbb::parallel_while&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00204.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">tbb::simple_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner  <a href="a00216.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::simple_partitioner::partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">tbb::auto_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00167.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::auto_partitioner::partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">tbb::affinity_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00162.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">tbb::filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00189.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">tbb::pipeline</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing pipeling that applies filters to items.  <a href="a00206.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">tbb::queuing_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing lock with local-only spinning.  <a href="a00208.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">tbb::queuing_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00209.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">tbb::queuing_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reader-writer lock with local-only spinning.  <a href="a00210.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">tbb::queuing_rw_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00211.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">tbb::recursive_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00214.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">tbb::recursive_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00215.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">tbb::spin_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00217.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">tbb::spin_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents acquisition of a mutex.  <a href="a00218.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">tbb::spin_rw_mutex_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00219.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">tbb::spin_rw_mutex_v3::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00220.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">tbb::task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00228.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">tbb::empty_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00188.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">tbb::task_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00229.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">tbb::task_scheduler_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing reference to tbb scheduler.  <a href="a00231.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">tbb::tbb_allocator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5  <a href="a00232.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::tbb_allocator&lt; T &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">tbb::tbb_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00233.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::tbb_allocator&lt; void &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">tbb::bad_last_alloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00168.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">tbb::split</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00221.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">tbb::tick_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00236.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">tbb::tick_count::interval_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relative time interval.  <a href="a00237.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>parallel_do</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga3" doxytag="tbb::parallel_do"></a>
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga3">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga4" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga4">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00216.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00216.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner, or default partitioner if no partitioner is specified. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga5" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga5">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00167.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00167.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga6" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga6">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00162.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00162.html">affinity_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_reduce</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga7" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga7">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00216.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00216.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00216.html">simple_partitioner</a>, or default partitioner if no partitioner is specified. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga8" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga8">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00167.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00167.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga9" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga9">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00162.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00167.html">auto_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_scan</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga10" doxytag="tbb::parallel_scan"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga10">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00216.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00216.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00216.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga11" doxytag="tbb::parallel_scan"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga11">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00167.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00167.html">auto_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_sort</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga13">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00281.html#ga13"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga14" doxytag="tbb::parallel_sort"></a>
template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga14">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga15" doxytag="tbb::parallel_sort"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga15">parallel_sort</a> (T *begin, T *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::spin_rw_mutex"></a>
typedef <a class="el" href="a00219.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::stack_size_type"></a>
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::task_scheduler_observer"></a>
typedef internal::task_scheduler_observer_v3&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::assertion_handler_type"></a>
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#a6">assertion_handler_type</a> )(const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for an assertion handler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="tbb::tbb_thread"></a>
typedef <a class="el" href="a00234.html">internal::tbb_thread_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#a7">tbb_thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Users reference thread class by name tbb_thread. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#a37">memory_semantics</a> { <a class="el" href="a00278.html#a37a0">__TBB_full_fence</a>, 
<a class="el" href="a00278.html#a37a1">acquire</a>, 
<a class="el" href="a00278.html#a37a2">release</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies memory fencing.  <a href="#a37">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a8" doxytag="tbb::operator=="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00172.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00172.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a9" doxytag="tbb::operator!="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00172.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00172.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a10" doxytag="tbb::operator=="></a>
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a11" doxytag="tbb::operator!="></a>
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a12" doxytag="tbb::swap"></a>
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;a, <a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a13" doxytag="tbb::operator=="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a14" doxytag="tbb::operator!="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a15" doxytag="tbb::operator<"></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a16" doxytag="tbb::operator>"></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a17" doxytag="tbb::operator<="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a18" doxytag="tbb::operator>="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a19" doxytag="tbb::swap"></a>
template&lt;typename T, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00182.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a32" doxytag="tbb::operator=="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00232.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00232.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a33" doxytag="tbb::operator!="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00232.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00232.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a34" doxytag="tbb::swap"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00234.html">internal::tbb_thread_v3</a> &amp;t1, <a class="el" href="a00234.html">internal::tbb_thread_v3</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="tbb::move"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>move</b> (<a class="el" href="a00234.html">tbb_thread</a> &amp;t1, <a class="el" href="a00234.html">tbb_thread</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a36" doxytag="tbb::operator-"></a>
<a class="el" href="a00237.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00236.html">tick_count</a> &amp;t1, const <a class="el" href="a00236.html">tick_count</a> &amp;t0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace tbb contains all components of the library. <hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a37" doxytag="tbb::memory_semantics"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="a00278.html#a37">memory_semantics</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specifies memory fencing. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a37a0" doxytag="__TBB_full_fence"></a>__TBB_full_fence</em>&nbsp;</td><td>
For internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a37a1" doxytag="acquire"></a>acquire</em>&nbsp;</td><td>
Acquire fence. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a37a2" doxytag="release"></a>release</em>&nbsp;</td><td>
Release fence. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
