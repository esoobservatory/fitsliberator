<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference</h1>Unordered map from Key to T.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00289.html">concurrent_hash_map.h</a>&gt;</code>
<p>
Inherits <a class="el" href="a00195.html">tbb::internal::hash_map_base</a>.
<p>
Inheritance diagram for tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;:<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="a00024.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w0" doxytag="tbb::concurrent_hash_map::key_type"></a>
typedef Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w1" doxytag="tbb::concurrent_hash_map::mapped_type"></a>
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w2" doxytag="tbb::concurrent_hash_map::value_type"></a>
typedef std::pair&lt; const Key,<br>
 T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w3" doxytag="tbb::concurrent_hash_map::size_type"></a>
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w4" doxytag="tbb::concurrent_hash_map::difference_type"></a>
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w5" doxytag="tbb::concurrent_hash_map::pointer"></a>
typedef value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w6" doxytag="tbb::concurrent_hash_map::const_pointer"></a>
typedef const value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w7" doxytag="tbb::concurrent_hash_map::reference"></a>
typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w8" doxytag="tbb::concurrent_hash_map::const_reference"></a>
typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w9" doxytag="tbb::concurrent_hash_map::iterator"></a>
typedef <a class="el" href="a00196.html">internal::hash_map_iterator</a>&lt;<br>
 <a class="el" href="a00174.html">concurrent_hash_map</a>, value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w10" doxytag="tbb::concurrent_hash_map::const_iterator"></a>
typedef <a class="el" href="a00196.html">internal::hash_map_iterator</a>&lt;<br>
 <a class="el" href="a00174.html">concurrent_hash_map</a>, const <br>
value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w11" doxytag="tbb::concurrent_hash_map::range_type"></a>
typedef <a class="el" href="a00197.html">internal::hash_map_range</a>&lt;<br>
 <a class="el" href="a00196.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w12" doxytag="tbb::concurrent_hash_map::const_range_type"></a>
typedef <a class="el" href="a00197.html">internal::hash_map_range</a>&lt;<br>
 <a class="el" href="a00196.html">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w13" doxytag="tbb::concurrent_hash_map::allocator_type"></a>
typedef A&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="tbb::concurrent_hash_map::concurrent_hash_map"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a0">concurrent_hash_map</a> (const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="tbb::concurrent_hash_map::concurrent_hash_map"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a1">concurrent_hash_map</a> (const <a class="el" href="a00174.html">concurrent_hash_map</a> &amp;table, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a2" doxytag="tbb::concurrent_hash_map::concurrent_hash_map"></a>
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00174.html#a2">concurrent_hash_map</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::concurrent_hash_map::operator="></a>
<a class="el" href="a00174.html">concurrent_hash_map</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a3">operator=</a> (const <a class="el" href="a00174.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::concurrent_hash_map::clear"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a4">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::concurrent_hash_map::~concurrent_hash_map"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a5">~concurrent_hash_map</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table and destroy it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::concurrent_hash_map::range"></a>
<a class="el" href="a00197.html">range_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="tbb::concurrent_hash_map::range"></a>
<a class="el" href="a00197.html">const_range_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="tbb::concurrent_hash_map::begin"></a>
<a class="el" href="a00196.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="tbb::concurrent_hash_map::end"></a>
<a class="el" href="a00196.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="tbb::concurrent_hash_map::begin"></a>
<a class="el" href="a00196.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="tbb::concurrent_hash_map::end"></a>
<a class="el" href="a00196.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="tbb::concurrent_hash_map::equal_range"></a>
std::pair&lt; <a class="el" href="a00196.html">iterator</a>, <a class="el" href="a00196.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="tbb::concurrent_hash_map::equal_range"></a>
std::pair&lt; <a class="el" href="a00196.html">const_iterator</a>,<br>
 <a class="el" href="a00196.html">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a14">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of items in table.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="tbb::concurrent_hash_map::empty"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a15">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="a00174.html#a14">size()</a>==0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="tbb::concurrent_hash_map::max_size"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a16">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="tbb::concurrent_hash_map::get_allocator"></a>
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a17">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="tbb::concurrent_hash_map::swap"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a18">swap</a> (<a class="el" href="a00174.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="tbb::concurrent_hash_map::count"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a19">count</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return count of items (0 or 1). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a20">find</a> (<a class="el" href="a00176.html">const_accessor</a> &amp;result, const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a21">find</a> (<a class="el" href="a00175.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a22">insert</a> (<a class="el" href="a00176.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a23">insert</a> (<a class="el" href="a00175.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a24">insert</a> (<a class="el" href="a00176.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a25">insert</a> (<a class="el" href="a00175.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a26">insert</a> (const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#a26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a27" doxytag="tbb::concurrent_hash_map::insert"></a>
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00174.html#a27">insert</a> (I first, I last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert range [first, last). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a28">erase</a> (const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a29">erase</a> (<a class="el" href="a00176.html">const_accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by <a class="el" href="a00176.html">const_accessor</a>.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html#a30">erase</a> (<a class="el" href="a00175.html">accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by accessor.  <a href="#a30"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n0" doxytag="tbb::concurrent_hash_map::internal::hash_map_iterator"></a>
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n1" doxytag="tbb::concurrent_hash_map::internal::hash_map_range"></a>
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n2" doxytag="tbb::concurrent_hash_map::node"></a>
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n3" doxytag="tbb::concurrent_hash_map::const_accessor"></a>
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n4" doxytag="tbb::concurrent_hash_map::chain"></a>
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>chain</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n5" doxytag="tbb::concurrent_hash_map::segment"></a>
struct&nbsp;</td><td class="memItemRight" valign="bottom"><b>segment</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Key, typename T, typename HashCompare, typename A&gt;<br>
 class tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</h3>

Unordered map from Key to T. 
<p>
<a class="el" href="a00174.html">concurrent_hash_map</a> is associative container with concurrent access.<p>
<dl compact><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1).</dd></dl>
<dl compact><dt><b>Exception Safety</b></dt><dd><ul>
<li>Hash function is not permitted to throw an exception. User-defined types Key and T are forbidden from throwing an exception in destructors.</li><li>If exception happens during <a class="el" href="a00174.html#a22">insert()</a> operations, it has no effect (unless exception raised by HashCompare::hash() function during grow_segment).</li><li>If exception happens during <a class="el" href="a00174.html#a3">operator=()</a> operation, the container can have a part of source items, and methods <a class="el" href="a00174.html#a14">size()</a> and <a class="el" href="a00174.html#a15">empty()</a> can return wrong results.</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Fixed exception-safety</li><li>Added template argument for allocator</li><li>Added allocator argument in constructors</li><li>Added constructor from a range of iterators</li><li>Added several new overloaded <a class="el" href="a00174.html#a22">insert()</a> methods</li><li>Added <a class="el" href="a00174.html#a17">get_allocator()</a></li><li>Added <a class="el" href="a00174.html#a18">swap()</a></li><li>Added <a class="el" href="a00174.html#a19">count()</a></li><li>Added overloaded <a class="el" href="a00174.html#a30">erase(accessor &amp;)</a> and <a class="el" href="a00174.html#a29">erase(const_accessor&amp;)</a></li><li>Added equal_range() [const]</li><li>Added [const_]pointer, [const_]reference, and allocator_type types</li><li>Added global functions: operator==(), operator!=(), and <a class="el" href="a00174.html#a18">swap()</a> </li></ul>
</dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a30" doxytag="tbb::concurrent_hash_map::erase"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00175.html">accessor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>item_accessor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase item by accessor. 
<p>
Return true if item was erased by particularly this call.     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="tbb::concurrent_hash_map::erase"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00176.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>item_accessor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase item by <a class="el" href="a00176.html">const_accessor</a>. 
<p>
Return true if item was erased by particularly this call.     </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="tbb::concurrent_hash_map::erase"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Key &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase item. 
<p>
Return true if item was erased by particularly this call.     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="tbb::concurrent_hash_map::find"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00175.html">accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const Key &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find item and acquire a write lock on the item. 
<p>
Return true if item is found, false otherwise.     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="tbb::concurrent_hash_map::find"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00176.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const Key &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find item and acquire a read lock on the item. 
<p>
Return true if item is found, false otherwise.     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="tbb::concurrent_hash_map::insert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const value_type &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>value</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert item by copying if there is no such key present already. 
<p>
Returns true if item is inserted.     </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="tbb::concurrent_hash_map::insert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00175.html">accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const value_type &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert item by copying if there is no such key present already and acquire a write lock on the item. 
<p>
Returns true if item is new.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="tbb::concurrent_hash_map::insert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00176.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const value_type &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert item by copying if there is no such key present already and acquire a read lock on the item. 
<p>
Returns true if item is new.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="tbb::concurrent_hash_map::insert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00175.html">accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const Key &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert item (if not already present) and acquire a write lock on the item. 
<p>
Returns true if item is new.     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="tbb::concurrent_hash_map::insert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00176.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const Key &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert item (if not already present) and acquire a read lock on the item. 
<p>
Returns true if item is new.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="tbb::concurrent_hash_map::size"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00174.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::size_type <a class="el" href="a00174.html">tbb::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::size           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Number of items in table. 
<p>
Be aware that this method is relatively slow compared to the typical <a class="el" href="a00174.html#a14">size()</a> method for an STL container.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00289.html">concurrent_hash_map.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
