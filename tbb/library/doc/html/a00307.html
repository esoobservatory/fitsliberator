<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>task.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>task.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_task_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_task_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 
00026 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#include "tbb/cache_aligned_allocator.h"</span>
00028 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00029 
00030 <span class="keyword">namespace </span>tbb {
00031 
00032 <span class="keyword">class </span>task;
00033 <span class="keyword">class </span>task_list;
00034 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00035 <span class="preprocessor"></span><span class="keyword">class </span>task_group_context;
00036 <span class="keyword">class </span>tbb_exception;
00037 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00038 
00040 <span class="keyword">namespace </span>internal {
00041 
00042     <span class="keyword">class </span>scheduler {
00043     <span class="keyword">public</span>:
00045         <span class="keyword">virtual</span> <span class="keywordtype">void</span> spawn( task&amp; first, task*&amp; next ) = 0;
00046 
00048         <span class="keyword">virtual</span> <span class="keywordtype">void</span> wait_for_all( task&amp; parent, task* child ) = 0;
00049 
00051         <span class="keyword">virtual</span> <span class="keywordtype">void</span> spawn_root_and_wait( task&amp; first, task*&amp; next ) = 0;
00052 
00054         <span class="comment">//  Have to have it just to shut up overzealous compilation warnings</span>
00055         <span class="keyword">virtual</span> ~scheduler() = 0;
00056     };
00057 
00059 
<a name="l00060"></a><a class="code" href="a00279.html#a11">00060</a>     <span class="keyword">typedef</span> <a class="code" href="a00279.html#a14">intptr</a> reference_count;
00061 
<a name="l00063"></a><a class="code" href="a00279.html#a12">00063</a>     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> affinity_id;
00064 
00065 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00066 <span class="preprocessor"></span>    <span class="keyword">struct </span>context_list_node_t {
00067         context_list_node_t *my_prev,
00068                             *my_next;
00069     };
00070 
00071     <span class="keyword">class </span>allocate_root_with_context_proxy {
00072         task_group_context&amp; my_context;
00073     <span class="keyword">public</span>:
00074         allocate_root_with_context_proxy ( task_group_context&amp; ctx ) : my_context(ctx) {}
00075         task&amp; allocate( size_t size ) <span class="keyword">const</span>;
00076         <span class="keywordtype">void</span> free( task&amp; ) <span class="keyword">const</span>;
00077     };
00078 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00079 
00080     <span class="keyword">class </span>allocate_root_proxy {
00081     <span class="keyword">public</span>:
00082         <span class="keyword">static</span> task&amp; allocate( size_t size );
00083         <span class="keyword">static</span> <span class="keywordtype">void</span> free( task&amp; );
00084     };
00085 
00086     <span class="keyword">class </span>allocate_continuation_proxy {
00087     <span class="keyword">public</span>:
00088         task&amp; allocate( size_t size ) <span class="keyword">const</span>;
00089         <span class="keywordtype">void</span> free( task&amp; ) <span class="keyword">const</span>;
00090     };
00091 
00092     <span class="keyword">class </span>allocate_child_proxy {
00093     <span class="keyword">public</span>:
00094         task&amp; allocate( size_t size ) <span class="keyword">const</span>;
00095         <span class="keywordtype">void</span> free( task&amp; ) <span class="keyword">const</span>;
00096     };
00097 
00098     <span class="keyword">class </span>allocate_additional_child_of_proxy {
00099         task&amp; <span class="keyword">self</span>;
00100         task&amp; parent;
00101     <span class="keyword">public</span>:
00102         allocate_additional_child_of_proxy( task&amp; self_, task&amp; parent_ ) : self(self_), parent(parent_) {}
00103         task&amp; allocate( size_t size ) <span class="keyword">const</span>;
00104         <span class="keywordtype">void</span> free( task&amp; ) <span class="keyword">const</span>;
00105     };
00106 
00108 
<a name="l00113"></a><a class="code" href="a00230.html">00113</a>     <span class="keyword">class </span><a class="code" href="a00230.html">task_prefix</a> {
00114     <span class="keyword">private</span>:
00115         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00228.html">tbb::task</a>;
00116         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00229.html">tbb::task_list</a>;
00117         <span class="keyword">friend</span> <span class="keyword">class </span>internal::scheduler;
00118         <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_root_proxy;
00119         <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_child_proxy;
00120         <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_continuation_proxy;
00121         <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_additional_child_of_proxy;
00122 
00123 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00124 <span class="preprocessor"></span>
00125 
00128         task_group_context  *context;
00129 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00130         
00132 
00137         scheduler* origin;
00138 
00140         scheduler* owner;
00141 
00143 
00146         <a class="code" href="a00228.html">tbb::task</a>* parent;
00147 
00149 
00153         <a class="code" href="a00279.html#a11">reference_count</a> ref_count;
00154 
00156         <span class="keywordtype">int</span> depth;
00157 
00159 
00160         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> state;
00161 
00163 
00167         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> extra_state;
00168 
00169         <a class="code" href="a00279.html#a12">affinity_id</a> affinity;
00170 
00172         <a class="code" href="a00228.html">tbb::task</a>* next;
00173 
00175         <a class="code" href="a00228.html">tbb::task</a>&amp; <a class="code" href="a00228.html">task</a>() {<span class="keywordflow">return</span> *reinterpret_cast&lt;tbb::task*&gt;(<span class="keyword">this</span>+1);}
00176     };
00177 
00178 } <span class="comment">// namespace internal</span>
00180 <span class="comment"></span>
00181 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00182 <span class="preprocessor"></span>
00183 
00185 
00200 <span class="keyword">class </span>task_group_context : internal::no_copy
00201 {
00202 <span class="keyword">public</span>:
00203     <span class="keyword">enum</span> kind_type {
00204         isolated,
00205         bound
00206     };
00207 
00208 <span class="keyword">private</span>:
00209     <span class="keyword">union </span>{
00211         kind_type my_kind;
00212         uintptr_t _my_kind_aligner;
00213     };
00214 
00216     task_group_context *my_parent;
00217 
00219 
00221     internal::context_list_node_t my_node;
00222 
00224 
00227     <span class="keywordtype">char</span> _leading_padding[internal::NFS_MaxLineSize - 2 * <span class="keyword">sizeof</span>(uintptr_t)- <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - <span class="keyword">sizeof</span>(internal::context_list_node_t)];
00228     
00230     uintptr_t my_cancellation_requested;
00231     
00233 
00236     uintptr_t  my_version;
00237 
00239     tbb_exception *my_exception;
00240 
00242 
00245     <span class="keywordtype">void</span> *my_owner;
00246 
00248 
00249     <span class="keywordtype">char</span> _trailing_padding[internal::NFS_MaxLineSize - <span class="keyword">sizeof</span>(intptr_t) - 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*)];
00250 
00251 <span class="keyword">public</span>:
00252 
00253 
00255 
00272     task_group_context ( kind_type relation_with_parent = bound )
00273         : my_kind(relation_with_parent)
00274         , my_version(0)
00275     {
00276         init();
00277     }
00278 
00279     ~task_group_context ();
00280 
00282 
00289     <span class="keywordtype">void</span> reset ();
00290 
00292 
00299     <span class="keywordtype">bool</span> cancel_group_execution ();
00300 
00302     <span class="keywordtype">bool</span> is_group_execution_cancelled () <span class="keyword">const</span>;
00303 
00304 <span class="keyword">protected</span>:
00306 
00307     <span class="keywordtype">void</span> init ();
00308 
00309 <span class="keyword">private</span>:
00310     <span class="keyword">friend</span> <span class="keyword">class </span>task;
00311     <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_root_with_context_proxy;
00312 
00313     <span class="keyword">static</span> <span class="keyword">const</span> kind_type binding_required = bound;
00314     <span class="keyword">static</span> <span class="keyword">const</span> kind_type binding_completed = kind_type(bound+1);
00315 
00318     <span class="keywordtype">void</span> propagate_cancellation_from_ancestors ();
00319 }; <span class="comment">// class task_group_context</span>
00320 
00321 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00322 
00324 
<a name="l00325"></a><a class="code" href="a00228.html">00325</a> <span class="keyword">class </span><a class="code" href="a00228.html">task</a>: internal::no_copy {
00327     <span class="keywordtype">void</span> internal_set_ref_count( <span class="keywordtype">int</span> count );
00328 
00329 <span class="keyword">protected</span>:
<a name="l00331"></a><a class="code" href="a00228.html#b0">00331</a>     <a class="code" href="a00228.html">task</a>() {prefix().extra_state=1;}
00332 
00333 <span class="keyword">public</span>:
<a name="l00335"></a><a class="code" href="a00228.html#a0">00335</a>     <span class="keyword">virtual</span> ~<a class="code" href="a00228.html">task</a>() {}
00336 
00338     <span class="keyword">virtual</span> <a class="code" href="a00228.html">task</a>* execute() = 0;
00339 
<a name="l00341"></a><a class="code" href="a00228.html#w8">00341</a>     <span class="keyword">enum</span> state_type {
00343         executing,
00345         reexecute,
00347         ready,
00349         allocated,
00351         freed,
00353         recycle
00354     };
00355 
00356     <span class="comment">//------------------------------------------------------------------------</span>
00357     <span class="comment">// Allocating tasks</span>
00358     <span class="comment">//------------------------------------------------------------------------</span>
00359 
<a name="l00361"></a><a class="code" href="a00228.html#e0">00361</a>     <span class="keyword">static</span> internal::allocate_root_proxy allocate_root() {
00362         <span class="keywordflow">return</span> internal::allocate_root_proxy();
00363     }
00364 
00365 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00366 <span class="preprocessor"></span>
00367     <span class="keyword">static</span> internal::allocate_root_with_context_proxy allocate_root( task_group_context&amp; ctx ) {
00368         <span class="keywordflow">return</span> internal::allocate_root_with_context_proxy(ctx);
00369     }
00370 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00371 
00373 
<a name="l00374"></a><a class="code" href="a00228.html#a2">00374</a>     internal::allocate_continuation_proxy&amp; allocate_continuation() {
00375         <span class="keywordflow">return</span> *reinterpret_cast&lt;internal::allocate_continuation_proxy*&gt;(<span class="keyword">this</span>);
00376     }
00377 
<a name="l00379"></a><a class="code" href="a00228.html#a3">00379</a>     internal::allocate_child_proxy&amp; allocate_child() {
00380         <span class="keywordflow">return</span> *reinterpret_cast&lt;internal::allocate_child_proxy*&gt;(<span class="keyword">this</span>);
00381     }
00382 
00384 
<a name="l00386"></a><a class="code" href="a00228.html#a4">00386</a>     internal::allocate_additional_child_of_proxy allocate_additional_child_of( <a class="code" href="a00228.html">task</a>&amp; t ) {
00387         <span class="keywordflow">return</span> internal::allocate_additional_child_of_proxy(*<span class="keyword">this</span>,t);
00388     }
00389 
00391 
00395     <span class="keywordtype">void</span> destroy( <a class="code" href="a00228.html">task</a>&amp; victim );
00396 
00397     <span class="comment">//------------------------------------------------------------------------</span>
00398     <span class="comment">// Recycling of tasks</span>
00399     <span class="comment">//------------------------------------------------------------------------</span>
00400 
00402 
<a name="l00408"></a><a class="code" href="a00228.html#a6">00408</a>     <span class="keywordtype">void</span> recycle_as_continuation() {
00409         __TBB_ASSERT( prefix().state==executing, <span class="stringliteral">"execute not running?"</span> );
00410         prefix().state = allocated;
00411     }
00412 
00414 
<a name="l00415"></a><a class="code" href="a00228.html#a7">00415</a>     <span class="keywordtype">void</span> recycle_as_safe_continuation() {
00416         __TBB_ASSERT( prefix().state==executing, <span class="stringliteral">"execute not running?"</span> );
00417         prefix().state = recycle;
00418     }
00419 
<a name="l00421"></a><a class="code" href="a00228.html#a8">00421</a>     <span class="keywordtype">void</span> recycle_as_child_of( <a class="code" href="a00228.html">task</a>&amp; new_parent ) {
00422         <a class="code" href="a00230.html">internal::task_prefix</a>&amp; p = prefix();
00423         __TBB_ASSERT( prefix().state==executing||prefix().state==allocated, <span class="stringliteral">"execute not running, or already recycled"</span> );
00424         __TBB_ASSERT( prefix().ref_count==0, <span class="stringliteral">"no child tasks allowed when recycled as a child"</span> );
00425         __TBB_ASSERT( p.<a class="code" href="a00230.html#r2">parent</a>==NULL, <span class="stringliteral">"parent must be null"</span> );
00426         __TBB_ASSERT( new_parent.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r5">state</a>&lt;=recycle, <span class="stringliteral">"corrupt parent's state"</span> );
00427         __TBB_ASSERT( new_parent.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r5">state</a>!=freed, <span class="stringliteral">"parent already freed"</span> );
00428         p.<a class="code" href="a00230.html#r5">state</a> = allocated;
00429         p.<a class="code" href="a00230.html#r2">parent</a> = &amp;new_parent;
00430         p.<a class="code" href="a00230.html#r4">depth</a> = new_parent.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r4">depth</a>+1;
00431 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00432 <span class="preprocessor"></span>        p.context = new_parent.<a class="code" href="a00228.html#d1">prefix</a>().context;
00433 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00434     }
00435 
00437 
<a name="l00438"></a><a class="code" href="a00228.html#a9">00438</a>     <span class="keywordtype">void</span> recycle_to_reexecute() {
00439         __TBB_ASSERT( prefix().state==executing, <span class="stringliteral">"execute not running, or already recycled"</span> );
00440         __TBB_ASSERT( prefix().ref_count==0, <span class="stringliteral">"no child tasks allowed when recycled for reexecution"</span> );
00441         prefix().<a class="code" href="a00230.html#r5">state</a> = reexecute;
00442     }
00443 
00445 
<a name="l00446"></a><a class="code" href="a00228.html#w0">00446</a>     <span class="keyword">typedef</span> internal::intptr depth_type;
00447 
<a name="l00449"></a><a class="code" href="a00228.html#a10">00449</a>     depth_type depth()<span class="keyword"> const </span>{<span class="keywordflow">return</span> prefix().<a class="code" href="a00230.html#r4">depth</a>;}
00450 
00452 
<a name="l00453"></a><a class="code" href="a00228.html#a11">00453</a>     <span class="keywordtype">void</span> set_depth( depth_type new_depth ) {
00454         __TBB_ASSERT( state()!=ready, <span class="stringliteral">"cannot change depth of ready task"</span> );
00455         __TBB_ASSERT( new_depth&gt;=0, <span class="stringliteral">"depth cannot be negative"</span> );
00456         __TBB_ASSERT( new_depth==<span class="keywordtype">int</span>(new_depth), <span class="stringliteral">"integer overflow error"</span>);
00457         prefix().<a class="code" href="a00230.html#r4">depth</a> = int(new_depth);
00458     }
00459 
00461 
<a name="l00462"></a><a class="code" href="a00228.html#a12">00462</a>     <span class="keywordtype">void</span> add_to_depth( <span class="keywordtype">int</span> delta ) {
00463         __TBB_ASSERT( state()!=ready, <span class="stringliteral">"cannot change depth of ready task"</span> );
00464         __TBB_ASSERT( prefix().depth&gt;=-delta, <span class="stringliteral">"depth cannot be negative"</span> );
00465         prefix().<a class="code" href="a00230.html#r4">depth</a>+=delta;
00466     }
00467 
00468     <span class="comment">//------------------------------------------------------------------------</span>
00469     <span class="comment">// Spawning and blocking</span>
00470     <span class="comment">//------------------------------------------------------------------------</span>
00471 
<a name="l00473"></a><a class="code" href="a00228.html#a13">00473</a>     <span class="keywordtype">void</span> set_ref_count( <span class="keywordtype">int</span> count ) {
00474 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00475 <span class="preprocessor"></span>        internal_set_ref_count(count);
00476 <span class="preprocessor">#else</span>
00477 <span class="preprocessor"></span>        prefix().<a class="code" href="a00230.html#r3">ref_count</a> = count;
00478 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_ASSERT */</span>
00479     }
00480 
00482 
<a name="l00486"></a><a class="code" href="a00228.html#a14">00486</a>     <span class="keywordtype">void</span> spawn( <a class="code" href="a00228.html">task</a>&amp; child ) {
00487         __TBB_ASSERT( is_owned_by_current_thread(), <span class="stringliteral">"'this' not owned by current thread"</span> );
00488         prefix().<a class="code" href="a00230.html#r1">owner</a>-&gt;spawn( child, child.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r8">next</a> );
00489     }
00490 
00492 
00493     <span class="keywordtype">void</span> spawn( <a class="code" href="a00229.html">task_list</a>&amp; list );
00494 
<a name="l00496"></a><a class="code" href="a00228.html#a16">00496</a>     <span class="keywordtype">void</span> spawn_and_wait_for_all( <a class="code" href="a00228.html">task</a>&amp; child ) {
00497         __TBB_ASSERT( is_owned_by_current_thread(), <span class="stringliteral">"'this' not owned by current thread"</span> );
00498         prefix().<a class="code" href="a00230.html#r1">owner</a>-&gt;wait_for_all( *<span class="keyword">this</span>, &amp;child );
00499     }
00500 
00502     <span class="keywordtype">void</span> spawn_and_wait_for_all( <a class="code" href="a00229.html">task_list</a>&amp; list );
00503 
00505 
<a name="l00507"></a><a class="code" href="a00228.html#e1">00507</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> spawn_root_and_wait( <a class="code" href="a00228.html">task</a>&amp; root ) {
00508         __TBB_ASSERT( root.<a class="code" href="a00228.html#a23">is_owned_by_current_thread</a>(), <span class="stringliteral">"root not owned by current thread"</span> );
00509         root.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r1">owner</a>-&gt;spawn_root_and_wait( root, root.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r8">next</a> );
00510     }
00511 
00513 
00515     <span class="keyword">static</span> <span class="keywordtype">void</span> spawn_root_and_wait( <a class="code" href="a00229.html">task_list</a>&amp; root_list );
00516 
00518 
<a name="l00519"></a><a class="code" href="a00228.html#a18">00519</a>     <span class="keywordtype">void</span> wait_for_all() {
00520         __TBB_ASSERT( is_owned_by_current_thread(), <span class="stringliteral">"'this' not owned by current thread"</span> );
00521         prefix().<a class="code" href="a00230.html#r1">owner</a>-&gt;wait_for_all( *<span class="keyword">this</span>, NULL );
00522     }
00523 
00525     <span class="keyword">static</span> <a class="code" href="a00228.html">task</a>&amp; <span class="keyword">self</span>();
00526 
<a name="l00528"></a><a class="code" href="a00228.html#a19">00528</a>     <a class="code" href="a00228.html">task</a>* parent()<span class="keyword"> const </span>{<span class="keywordflow">return</span> prefix().<a class="code" href="a00230.html#r2">parent</a>;}
00529 
<a name="l00531"></a><a class="code" href="a00228.html#a20">00531</a>     <span class="keywordtype">bool</span> is_stolen_task()<span class="keyword"> const </span>{
00532         <a class="code" href="a00230.html">internal::task_prefix</a>&amp; p = prefix();
00533         <a class="code" href="a00230.html">internal::task_prefix</a>&amp; q = parent()-&gt;<a class="code" href="a00228.html#d1">prefix</a>();
00534         <span class="keywordflow">return</span> p.<a class="code" href="a00230.html#r1">owner</a>!=q.<a class="code" href="a00230.html#r1">owner</a>;
00535     }
00536 
00537     <span class="comment">//------------------------------------------------------------------------</span>
00538     <span class="comment">// Debugging</span>
00539     <span class="comment">//------------------------------------------------------------------------</span>
00540 
<a name="l00542"></a><a class="code" href="a00228.html#a21">00542</a>     state_type state()<span class="keyword"> const </span>{<span class="keywordflow">return</span> state_type(prefix().state);}
00543 
<a name="l00545"></a><a class="code" href="a00228.html#a22">00545</a>     <span class="keywordtype">int</span> ref_count()<span class="keyword"> const </span>{
00546 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00547 <span class="preprocessor"></span>        internal::reference_count ref_count = prefix().<a class="code" href="a00230.html#r3">ref_count</a>;
00548         __TBB_ASSERT( ref_count==<span class="keywordtype">int</span>(ref_count), <span class="stringliteral">"integer overflow error"</span>);
00549 <span class="preprocessor">#endif</span>
00550 <span class="preprocessor"></span>        <span class="keywordflow">return</span> int(prefix().ref_count);
00551     }
00552 
00554     <span class="keywordtype">bool</span> is_owned_by_current_thread() <span class="keyword">const</span>;
00555 
00556     <span class="comment">//------------------------------------------------------------------------</span>
00557     <span class="comment">// Affinity</span>
00558     <span class="comment">//------------------------------------------------------------------------</span>
00559  
00561 
<a name="l00562"></a><a class="code" href="a00228.html#w1">00562</a>     <span class="keyword">typedef</span> internal::affinity_id affinity_id;
00563 
<a name="l00565"></a><a class="code" href="a00228.html#a24">00565</a>     <span class="keywordtype">void</span> set_affinity( affinity_id <span class="keywordtype">id</span> ) {prefix().<a class="code" href="a00230.html#r7">affinity</a> = id;}
00566 
<a name="l00568"></a><a class="code" href="a00228.html#a25">00568</a>     affinity_id affinity()<span class="keyword"> const </span>{<span class="keywordflow">return</span> prefix().<a class="code" href="a00230.html#r7">affinity</a>;}
00569 
00571 
00575     <span class="keyword">virtual</span> <span class="keywordtype">void</span> note_affinity( affinity_id <span class="keywordtype">id</span> );
00576 
00577 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00578 <span class="preprocessor"></span>
00579 
00580     <span class="keywordtype">bool</span> cancel_group_execution () { <span class="keywordflow">return</span> prefix().context-&gt;cancel_group_execution(); }
00581 
00583     <span class="keywordtype">bool</span> is_cancelled ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> prefix().context-&gt;is_group_execution_cancelled(); }
00584 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00585 
00586 <span class="keyword">private</span>:
00587     <span class="keyword">friend</span> <span class="keyword">class </span>task_list;
00588     <span class="keyword">friend</span> <span class="keyword">class </span>internal::scheduler;
00589     <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_root_proxy;
00590 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00591 <span class="preprocessor"></span>    <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_root_with_context_proxy;
00592 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00593     <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_continuation_proxy;
00594     <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_child_proxy;
00595     <span class="keyword">friend</span> <span class="keyword">class </span>internal::allocate_additional_child_of_proxy;
00596 
00598 
00599     internal::task_prefix&amp; prefix( internal::version_tag* = NULL )<span class="keyword"> const </span>{
00600         <span class="keywordflow">return</span> reinterpret_cast&lt;internal::task_prefix*&gt;(const_cast&lt;task*&gt;(<span class="keyword">this</span>))[-1];
00601     }
00602 }; <span class="comment">// class task</span>
00603 
00605 
<a name="l00606"></a><a class="code" href="a00188.html">00606</a> <span class="keyword">class </span><a class="code" href="a00188.html">empty_task</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a> {
00607     <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute() {
00608         <span class="keywordflow">return</span> NULL;
00609     }
00610 };
00611 
00613 
<a name="l00615"></a><a class="code" href="a00229.html">00615</a> <span class="keyword">class </span><a class="code" href="a00229.html">task_list</a>: internal::no_copy {
00616 <span class="keyword">private</span>:
00617     <a class="code" href="a00228.html">task</a>* first;
00618     <a class="code" href="a00228.html">task</a>** next_ptr;
00619     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00228.html">task</a>;
00620 <span class="keyword">public</span>:
<a name="l00622"></a><a class="code" href="a00229.html#a0">00622</a>     <a class="code" href="a00229.html">task_list</a>() : first(NULL), next_ptr(&amp;first) {}
00623 
<a name="l00625"></a><a class="code" href="a00229.html#a1">00625</a>     ~<a class="code" href="a00229.html">task_list</a>() {}
00626 
<a name="l00628"></a><a class="code" href="a00229.html#a2">00628</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !first;}
00629 
<a name="l00631"></a><a class="code" href="a00229.html#a3">00631</a>     <span class="keywordtype">void</span> push_back( <a class="code" href="a00228.html">task</a>&amp; <a class="code" href="a00228.html">task</a> ) {
00632         task.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r8">next</a> = NULL;
00633         *next_ptr = &amp;task;
00634         next_ptr = &amp;task.<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r8">next</a>;
00635     }
00636 
<a name="l00638"></a><a class="code" href="a00229.html#a4">00638</a>     <a class="code" href="a00228.html">task</a>&amp; pop_front() {
00639         __TBB_ASSERT( !empty(), <span class="stringliteral">"attempt to pop item from empty task_list"</span> );
00640         <a class="code" href="a00228.html">task</a>* result = first;
00641         first = result-&gt;<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r8">next</a>;
00642         <span class="keywordflow">if</span>( !first ) next_ptr = &amp;first;
00643         <span class="keywordflow">return</span> *result;
00644     }
00645 
<a name="l00647"></a><a class="code" href="a00229.html#a5">00647</a>     <span class="keywordtype">void</span> clear() {
00648         first=NULL;
00649         next_ptr=&amp;first;
00650     }
00651 };
00652 
<a name="l00653"></a><a class="code" href="a00228.html#a15">00653</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> task::spawn( <a class="code" href="a00229.html">task_list</a>&amp; list ) {
00654     __TBB_ASSERT( <a class="code" href="a00228.html#a23">is_owned_by_current_thread</a>(), <span class="stringliteral">"'this' not owned by current thread"</span> );
00655     <span class="keywordflow">if</span>( <a class="code" href="a00228.html">task</a>* t = list.<a class="code" href="a00229.html#r0">first</a> ) {
00656         prefix().<a class="code" href="a00230.html#r1">owner</a>-&gt;spawn( *t, *list.<a class="code" href="a00229.html#r1">next_ptr</a> );
00657         list.<a class="code" href="a00229.html#a5">clear</a>();
00658     }
00659 }
00660 
<a name="l00661"></a><a class="code" href="a00228.html#e2">00661</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> task::spawn_root_and_wait( <a class="code" href="a00229.html">task_list</a>&amp; root_list ) {
00662     <span class="keywordflow">if</span>( <a class="code" href="a00228.html">task</a>* t = root_list.<a class="code" href="a00229.html#r0">first</a> ) {
00663         __TBB_ASSERT( t-&gt;<a class="code" href="a00228.html#a23">is_owned_by_current_thread</a>(), <span class="stringliteral">"'this' not owned by current thread"</span> );
00664         t-&gt;<a class="code" href="a00228.html#d1">prefix</a>().<a class="code" href="a00230.html#r1">owner</a>-&gt;spawn_root_and_wait( *t, *root_list.<a class="code" href="a00229.html#r1">next_ptr</a> );
00665         root_list.<a class="code" href="a00229.html#a5">clear</a>();
00666     }
00667 }
00668 
00669 } <span class="comment">// namespace tbb</span>
00670 
00671 <span class="keyword">inline</span> <span class="keywordtype">void</span> *operator new( size_t bytes, <span class="keyword">const</span> tbb::internal::allocate_root_proxy&amp; p ) {
00672     <span class="keywordflow">return</span> &amp;p.allocate(bytes);
00673 }
00674 
00675 <span class="keyword">inline</span> <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* task, <span class="keyword">const</span> tbb::internal::allocate_root_proxy&amp; p ) {
00676     p.free( *static_cast&lt;tbb::task*&gt;(task) );
00677 }
00678 
00679 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00680 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> *operator new( size_t bytes, <span class="keyword">const</span> tbb::internal::allocate_root_with_context_proxy&amp; p ) {
00681     <span class="keywordflow">return</span> &amp;p.allocate(bytes);
00682 }
00683 
00684 <span class="keyword">inline</span> <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* task, <span class="keyword">const</span> tbb::internal::allocate_root_with_context_proxy&amp; p ) {
00685     p.free( *static_cast&lt;tbb::task*&gt;(task) );
00686 }
00687 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_EXCEPTIONS */</span>
00688 
00689 <span class="keyword">inline</span> <span class="keywordtype">void</span> *operator new( size_t bytes, <span class="keyword">const</span> tbb::internal::allocate_continuation_proxy&amp; p ) {
00690     <span class="keywordflow">return</span> &amp;p.allocate(bytes);
00691 }
00692 
00693 <span class="keyword">inline</span> <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* task, <span class="keyword">const</span> tbb::internal::allocate_continuation_proxy&amp; p ) {
00694     p.free( *static_cast&lt;tbb::task*&gt;(task) );
00695 }
00696 
00697 <span class="keyword">inline</span> <span class="keywordtype">void</span> *operator new( size_t bytes, <span class="keyword">const</span> tbb::internal::allocate_child_proxy&amp; p ) {
00698     <span class="keywordflow">return</span> &amp;p.allocate(bytes);
00699 }
00700 
00701 <span class="keyword">inline</span> <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* task, <span class="keyword">const</span> tbb::internal::allocate_child_proxy&amp; p ) {
00702     p.free( *static_cast&lt;tbb::task*&gt;(task) );
00703 }
00704 
00705 <span class="keyword">inline</span> <span class="keywordtype">void</span> *operator new( size_t bytes, <span class="keyword">const</span> tbb::internal::allocate_additional_child_of_proxy&amp; p ) {
00706     <span class="keywordflow">return</span> &amp;p.allocate(bytes);
00707 }
00708 
00709 <span class="keyword">inline</span> <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* task, <span class="keyword">const</span> tbb::internal::allocate_additional_child_of_proxy&amp; p ) {
00710     p.free( *static_cast&lt;tbb::task*&gt;(task) );
00711 }
00712 
00713 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_task_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
