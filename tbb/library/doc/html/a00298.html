<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>parallel_while.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>parallel_while.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_parallel_while</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_parallel_while</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "task.h"</span>
00025 <span class="preprocessor">#include &lt;new&gt;</span>
00026 
00027 <span class="keyword">namespace </span>tbb {
00028 
00029 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
00030 <span class="keyword">class </span>parallel_while;
00031 
00033 <span class="keyword">namespace </span>internal {
00034 
00035     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Stream, <span class="keyword">typename</span> Body&gt; <span class="keyword">class </span>while_task;
00036 
00038 
00040     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
<a name="l00041"></a><a class="code" href="a00241.html">00041</a>     <span class="keyword">class </span><a class="code" href="a00241.html">while_iteration_task</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a> {
00042         <span class="keyword">const</span> Body&amp; my_body;
00043         <span class="keyword">typename</span> Body::argument_type my_value;
00044         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute() {
00045             my_body(my_value); 
00046             <span class="keywordflow">return</span> NULL;
00047         }
00048         <a class="code" href="a00241.html">while_iteration_task</a>( <span class="keyword">const</span> <span class="keyword">typename</span> Body::argument_type&amp; value, <span class="keyword">const</span> Body&amp; body ) : 
00049             my_body(body), my_value(value)
00050         {}
00051         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00240.html">while_group_task</a>;
00052         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00204.html">tbb::parallel_while</a>&lt;Body&gt;;
00053     };
00054 
00056 
00058     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
<a name="l00059"></a><a class="code" href="a00240.html">00059</a>     <span class="keyword">class </span><a class="code" href="a00240.html">while_group_task</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a> {
00060         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_arg_size = 4;         
00061         <span class="keyword">const</span> Body&amp; my_body;
00062         size_t size;
00063         <span class="keyword">typename</span> Body::argument_type my_arg[max_arg_size];
00064         <a class="code" href="a00240.html">while_group_task</a>( <span class="keyword">const</span> Body&amp; body ) : my_body(body), size(0) {} 
00065         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute() {
00066             <span class="keyword">typedef</span> <a class="code" href="a00241.html">while_iteration_task&lt;Body&gt;</a> iteration_type;
00067             __TBB_ASSERT( size&gt;0, NULL );
00068             <a class="code" href="a00229.html">task_list</a> list;
00069             <a class="code" href="a00228.html">task</a>* t; 
00070             size_t k=0; 
00071             <span class="keywordflow">for</span>(;;) {
00072                 t = <span class="keyword">new</span>( allocate_child() ) iteration_type(my_arg[k],my_body); 
00073                 <span class="keywordflow">if</span>( ++k==size ) <span class="keywordflow">break</span>;
00074                 list.<a class="code" href="a00229.html#a3">push_back</a>(*t);
00075             }
00076             set_ref_count(<span class="keywordtype">int</span>(k+1));
00077             spawn(list);
00078             spawn_and_wait_for_all(*t);
00079             <span class="keywordflow">return</span> NULL;
00080         }
00081         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Stream, <span class="keyword">typename</span> Body_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00242.html">while_task</a>;
00082     };
00083     
00085 
00087     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Stream, <span class="keyword">typename</span> Body&gt;
<a name="l00088"></a><a class="code" href="a00242.html">00088</a>     <span class="keyword">class </span><a class="code" href="a00242.html">while_task</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a> {
00089         Stream&amp; my_stream;
00090         <span class="keyword">const</span> Body&amp; my_body;
00091         <a class="code" href="a00188.html">empty_task</a>&amp; my_barrier;
00092         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute() {
00093             <span class="keyword">typedef</span> <a class="code" href="a00240.html">while_group_task&lt;Body&gt;</a> block_type;
00094             block_type&amp; t = *<span class="keyword">new</span>( allocate_additional_child_of(my_barrier) ) block_type(my_body);
00095             size_t k=0; 
00096             <span class="keywordflow">while</span>( my_stream.pop_if_present(t.my_arg[k]) ) {
00097                 <span class="keywordflow">if</span>( ++k==block_type::max_arg_size ) {
00098                     <span class="comment">// There might be more iterations.</span>
00099                     recycle_to_reexecute();
00100                     <span class="keywordflow">break</span>;
00101                 }
00102             }
00103             <span class="keywordflow">if</span>( k==0 ) {
00104                 destroy(t);
00105                 <span class="keywordflow">return</span> NULL;
00106             } <span class="keywordflow">else</span> {
00107                 t.<a class="code" href="a00240.html#r1">size</a> = k;
00108                 <span class="keywordflow">return</span> &amp;t;
00109             }
00110         }
00111         <a class="code" href="a00242.html">while_task</a>( Stream&amp; stream, <span class="keyword">const</span> Body&amp; body, <a class="code" href="a00188.html">empty_task</a>&amp; barrier ) : 
00112             my_stream(stream),
00113             my_body(body),
00114             my_barrier(barrier)
00115         {} 
00116         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00204.html">tbb::parallel_while</a>&lt;Body&gt;;
00117     };
00118 
00119 } <span class="comment">// namespace internal</span>
00121 <span class="comment"></span>
00123 
00128 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
<a name="l00129"></a><a class="code" href="a00204.html">00129</a> <span class="keyword">class </span><a class="code" href="a00204.html">parallel_while</a>: internal::no_copy {
00130 <span class="keyword">public</span>:
<a name="l00132"></a><a class="code" href="a00204.html#a0">00132</a>     <a class="code" href="a00204.html">parallel_while</a>() : my_body(NULL), my_barrier(NULL) {}
00133 
<a name="l00135"></a><a class="code" href="a00204.html#a1">00135</a>     ~<a class="code" href="a00204.html">parallel_while</a>() {
00136         <span class="keywordflow">if</span>( my_barrier ) {
00137             my_barrier-&gt;destroy(*my_barrier);    
00138             my_barrier = NULL;
00139         }
00140     }
00141 
<a name="l00143"></a><a class="code" href="a00204.html#w0">00143</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> Body::argument_type value_type;
00144 
00146 
00149     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Stream&gt;
00150     <span class="keywordtype">void</span> run( Stream&amp; stream, <span class="keyword">const</span> Body&amp; body );
00151 
00153 
00154     <span class="keywordtype">void</span> add( <span class="keyword">const</span> value_type&amp; item );
00155 
00156 <span class="keyword">private</span>:
00157     <span class="keyword">const</span> Body* my_body;
00158     <a class="code" href="a00188.html">empty_task</a>* my_barrier;
00159 };
00160 
00161 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
00162 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Stream&gt;
<a name="l00163"></a><a class="code" href="a00204.html#a2">00163</a> <span class="keywordtype">void</span> <a class="code" href="a00204.html">parallel_while&lt;Body&gt;::run</a>( Stream&amp; stream, <span class="keyword">const</span> Body&amp; body ) {
00164     <span class="keyword">using</span> <span class="keyword">namespace </span>internal;
00165     <a class="code" href="a00188.html">empty_task</a>&amp; barrier = *<span class="keyword">new</span>( task::allocate_root() ) <a class="code" href="a00188.html">empty_task</a>();
00166     my_body = &amp;body;
00167     my_barrier = &amp;barrier;
00168     my_barrier-&gt;<a class="code" href="a00228.html#a13">set_ref_count</a>(2);
00169     while_task&lt;Stream,Body&gt;&amp; w = *<span class="keyword">new</span>( my_barrier-&gt;<a class="code" href="a00228.html#a3">allocate_child</a>() ) while_task&lt;Stream,Body&gt;( stream, body, barrier );
00170     my_barrier-&gt;<a class="code" href="a00228.html#a16">spawn_and_wait_for_all</a>(w);
00171     my_barrier-&gt;<a class="code" href="a00228.html#a5">destroy</a>(*my_barrier);
00172     my_barrier = NULL;
00173     my_body = NULL;
00174 }
00175 
00176 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt;
<a name="l00177"></a><a class="code" href="a00204.html#a3">00177</a> <span class="keywordtype">void</span> <a class="code" href="a00204.html">parallel_while&lt;Body&gt;::add</a>( <span class="keyword">const</span> value_type&amp; item ) {
00178     __TBB_ASSERT(my_barrier,<span class="stringliteral">"attempt to add to parallel_while that is not running"</span>);
00179     <span class="keyword">typedef</span> <a class="code" href="a00241.html">internal::while_iteration_task&lt;Body&gt;</a> iteration_type;
00180     iteration_type&amp; i = *<span class="keyword">new</span>( task::self().allocate_additional_child_of(*my_barrier) ) iteration_type(item,*my_body);
00181     task::self().<a class="code" href="a00228.html#a14">spawn</a>( i );
00182 }
00183 
00184 } <span class="comment">// namespace </span>
00185 
00186 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_parallel_while */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
