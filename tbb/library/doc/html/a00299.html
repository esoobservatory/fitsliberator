<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>partitioner.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>partitioner.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_partitioner_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_partitioner_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "task.h"</span>
00025 
00026 <span class="keyword">namespace </span>tbb {
00027 <span class="keyword">class </span>affinity_partitioner;
00028 
00030 <span class="keyword">namespace </span>internal {
00031 size_t get_initial_auto_partitioner_divisor();
00032 
00034 
<a name="l00035"></a><a class="code" href="a00163.html">00035</a> <span class="keyword">class </span><a class="code" href="a00163.html">affinity_partitioner_base_v3</a>: <a class="code" href="a00200.html">no_copy</a> {
00036     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00162.html">tbb::affinity_partitioner</a>;
00038 
00039     <a class="code" href="a00279.html#a12">affinity_id</a>* my_array;
00041     size_t my_size;
00043     <a class="code" href="a00163.html">affinity_partitioner_base_v3</a>() : my_array(NULL), my_size(0) {}
00045     ~<a class="code" href="a00163.html">affinity_partitioner_base_v3</a>() {resize(0);}
00047 
00048     <span class="keywordtype">void</span> resize( <span class="keywordtype">unsigned</span> factor );
00049     <span class="keyword">friend</span> <span class="keyword">class </span>affinity_partition_type;
00050 };
00051 
<a name="l00053"></a><a class="code" href="a00205.html">00053</a> <span class="keyword">class </span><a class="code" href="a00205.html">partition_type_base</a> {
00054 <span class="keyword">public</span>:
00055     <span class="keywordtype">void</span> set_affinity( <a class="code" href="a00228.html">task</a> &amp;t ) {}
00056     <span class="keywordtype">void</span> note_affinity( task::affinity_id <span class="keywordtype">id</span> ) {}
00057     <a class="code" href="a00228.html">task</a>* continue_after_execute_range( <a class="code" href="a00228.html">task</a>&amp; t ) {<span class="keywordflow">return</span> NULL;}
00058     <span class="keywordtype">bool</span> decide_whether_to_delay() {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
00059     <span class="keywordtype">void</span> spawn_or_delay( <span class="keywordtype">bool</span>, <a class="code" href="a00228.html">task</a>&amp; a, <a class="code" href="a00228.html">task</a>&amp; b ) {
00060         a.<a class="code" href="a00228.html#a14">spawn</a>(b);
00061     }
00062 };
00063 
00064 <span class="keyword">class </span>affinity_partition_type;
00065 
00066 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">class </span><a class="code" href="a00222.html">start_for</a>;
00067 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">class </span><a class="code" href="a00223.html">start_reduce</a>;
00068 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; <span class="keyword">class </span><a class="code" href="a00224.html">start_reduce_with_affinity</a>;
00069 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">class </span><a class="code" href="a00225.html">start_scan</a>;
00070 
00071 } <span class="comment">// namespace internal</span>
00073 <span class="comment"></span>
00075 
<a name="l00077"></a><a class="code" href="a00216.html">00077</a> <span class="keyword">class </span><a class="code" href="a00216.html">simple_partitioner</a> {
00078 <span class="keyword">public</span>:
00079     <a class="code" href="a00216.html">simple_partitioner</a>() {}
00080 <span class="keyword">private</span>:
00081     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00222.html">internal::start_for</a>;
00082     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00223.html">internal::start_reduce</a>;
00083     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00225.html">internal::start_scan</a>;
00084 
00085     <span class="keyword">class </span>partition_type: <span class="keyword">public</span> internal::partition_type_base {
00086     <span class="keyword">public</span>:
00087         <span class="keywordtype">bool</span> should_execute_range(<span class="keyword">const</span> <a class="code" href="a00228.html">task</a> &amp;t) {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
00088         partition_type( <span class="keyword">const</span> <a class="code" href="a00216.html">simple_partitioner</a>&amp; sp ) {}
00089         partition_type( <span class="keyword">const</span> partition_type&amp;, <a class="code" href="a00221.html">split</a> ) {}
00090     };
00091 };
00092 
00094 
<a name="l00097"></a><a class="code" href="a00167.html">00097</a> <span class="keyword">class </span><a class="code" href="a00167.html">auto_partitioner</a> {
00098 <span class="keyword">public</span>:
00099     <a class="code" href="a00167.html">auto_partitioner</a>() {}
00100 
00101 <span class="keyword">private</span>:
00102     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00222.html">internal::start_for</a>;
00103     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00223.html">internal::start_reduce</a>;
00104     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00225.html">internal::start_scan</a>;
00105 
00106     <span class="keyword">class </span>partition_type: <span class="keyword">public</span> internal::partition_type_base {
00107         size_t num_chunks;
00108         <span class="keyword">static</span> <span class="keyword">const</span> size_t VICTIM_CHUNKS = 4;
00109 <span class="keyword">public</span>:
00110         <span class="keywordtype">bool</span> should_execute_range(<span class="keyword">const</span> <a class="code" href="a00228.html">task</a> &amp;t) {
00111             <span class="keywordflow">if</span>( num_chunks&lt;VICTIM_CHUNKS &amp;&amp; t.<a class="code" href="a00228.html#a20">is_stolen_task</a>() )
00112                 num_chunks = VICTIM_CHUNKS;
00113             <span class="keywordflow">return</span> num_chunks==1;
00114         }
00115         partition_type( <span class="keyword">const</span> <a class="code" href="a00167.html">auto_partitioner</a>&amp; ap ) : num_chunks(internal::get_initial_auto_partitioner_divisor()) {}
00116         partition_type( partition_type&amp; pt, <a class="code" href="a00221.html">split</a> ) {
00117             num_chunks = pt.num_chunks /= 2u;
00118         }
00119     };
00120 };
00121 
<a name="l00123"></a><a class="code" href="a00162.html">00123</a> <span class="keyword">class </span><a class="code" href="a00162.html">affinity_partitioner</a>: <span class="keyword">private</span> internal::affinity_partitioner_base_v3 {
00124 <span class="keyword">public</span>:
00125     <a class="code" href="a00162.html">affinity_partitioner</a>() {}
00126 
00127 <span class="keyword">private</span>:
00128     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00222.html">internal::start_for</a>;
00129     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00224.html">internal::start_reduce_with_affinity</a>;
00130     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00225.html">internal::start_scan</a>;
00131 
00132     <span class="keyword">typedef</span> internal::affinity_partition_type partition_type;
00133     <span class="keyword">friend</span> <span class="keyword">class </span>internal::affinity_partition_type;
00134 };
00135 
00137 <span class="keyword">namespace </span>internal {
00138 
00139 <span class="keyword">class </span>affinity_partition_type: <span class="keyword">public</span> no_copy {
00141     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> factor = 16;
00142     <span class="keyword">static</span> <span class="keyword">const</span> size_t VICTIM_CHUNKS = 4;
00143 
00144     internal::affinity_id* my_array;
00145     <a class="code" href="a00229.html">task_list</a> delay_list;
00146     <span class="keywordtype">unsigned</span> map_begin, map_end;
00147     size_t num_chunks;
00148 <span class="keyword">public</span>:
00149     affinity_partition_type( <a class="code" href="a00162.html">affinity_partitioner</a>&amp; ap ) {
00150         __TBB_ASSERT( (factor&amp;(factor-1))==0, <span class="stringliteral">"factor must be power of two"</span> ); 
00151         ap.resize(factor);
00152         my_array = ap.my_array;
00153         map_begin = 0;
00154         map_end = unsigned(ap.my_size);
00155         num_chunks = internal::get_initial_auto_partitioner_divisor();
00156     }
00157     affinity_partition_type(affinity_partition_type&amp; p, split) : my_array(p.my_array) {
00158         __TBB_ASSERT( p.map_end-p.map_begin&lt;factor || (p.map_end-p.map_begin)%factor==0, NULL );
00159         num_chunks = p.num_chunks /= 2;
00160         <span class="keywordtype">unsigned</span> e = p.map_end;
00161         <span class="keywordtype">unsigned</span> d = (e - p.map_begin)/2;
00162         <span class="keywordflow">if</span>( d&gt;factor ) 
00163             d &amp;= 0u-factor;
00164         map_end = e;
00165         map_begin = p.map_end = e-d;
00166     }
00167 
00168     <span class="keywordtype">bool</span> should_execute_range(<span class="keyword">const</span> task &amp;t) {
00169         <span class="keywordflow">if</span>( num_chunks &lt; VICTIM_CHUNKS &amp;&amp; t.is_stolen_task() )
00170             num_chunks = VICTIM_CHUNKS;
00171         <span class="keywordflow">return</span> num_chunks == 1;
00172     }
00173 
00174     <span class="keywordtype">void</span> set_affinity( task &amp;t ) {
00175         <span class="keywordflow">if</span>( map_begin&lt;map_end )
00176             t.set_affinity( my_array[map_begin] );
00177     }
00178     <span class="keywordtype">void</span> note_affinity( task::affinity_id <span class="keywordtype">id</span> ) {
00179         <span class="keywordflow">if</span>( map_begin&lt;map_end ) 
00180             my_array[map_begin] = id;
00181     }
00182     task* continue_after_execute_range( task&amp; t ) {
00183         task* first = NULL;
00184         <span class="keywordflow">if</span>( !delay_list.empty() ) {
00185             first = &amp;delay_list.pop_front();
00186             <span class="keywordflow">while</span>( !delay_list.empty() ) {
00187                 t.spawn(*first);
00188                 first = &amp;delay_list.pop_front();
00189             }
00190         }
00191         <span class="keywordflow">return</span> first;
00192     }
00193     <span class="keywordtype">bool</span> decide_whether_to_delay() {
00194         <span class="comment">// The possible underflow caused by "-1u" is deliberate</span>
00195         <span class="keywordflow">return</span> (map_begin&amp;(factor-1))==0 &amp;&amp; map_end-map_begin-1u&lt;factor;
00196     }
00197     <span class="keywordtype">void</span> spawn_or_delay( <span class="keywordtype">bool</span> delay, task&amp; a, task&amp; b ) {
00198         <span class="keywordflow">if</span>( delay )  
00199             delay_list.push_back(b);
00200         <span class="keywordflow">else</span> 
00201             a.spawn(b);
00202     }
00203 };
00204 
00205 } <span class="comment">// namespace internal</span>
00207 <span class="comment"></span>
00208 
00209 } <span class="comment">// namespace tbb</span>
00210 
00211 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_partitioner_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
